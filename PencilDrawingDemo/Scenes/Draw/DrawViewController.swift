//
//  DrawViewController.swift
//  PencilDrawingDemo
//
//  Created by Konstantin Stolyarenko on 11.09.2023.
//  Copyright Â© 2023 SKS. All rights reserved.
//
//  This file was generated by the SKS Clean Swift Xcode Templates
//  with inspiration from http://clean-swift.com
//

import PencilKit
import UIKit

// MARK: - DrawDisplayLogic Protocol

protocol DrawDisplayLogic: AnyObject {
    func displaySavingResult(viewModel: Draw.DisplayData.SavingResult)
}

// MARK: - DrawViewController

class DrawViewController: UIViewController {

    // MARK: - Outlets

    @IBOutlet private var navigationToolbarViewContainer: UIView!
    @IBOutlet private var navigationToolbarViewTopConstraint: NSLayoutConstraint!
    @IBOutlet private var canvasView: PKCanvasView!

    // MARK: - Private Properties

    private var interactor: DrawBusinessLogic?
    private var router: (DrawRoutingLogic & DrawDataPassing)?

    private var navigationToolbarView: NavigationToolbarView?

    private let saveButton = UIButton(type: .system)
    private let inputDeviceButton = UIButton(type: .system)
    private let undoButton = UIButton(type: .system)
    private let redoButton = UIButton(type: .system)
    private let toolPickerButton = UIButton(type: .system)
    private let navigationToolbarButton = UIButton(type: .system)

    private var drawing = PKDrawing()
    private let toolPicker = PKToolPicker()

    private var isPencilOnly = false {
        didSet {
            canvasView.drawingPolicy = isPencilOnly ? .pencilOnly : .anyInput
            let image = isPencilOnly ? UIImage(systemName: "pencil") : UIImage(systemName: "hand.draw")
            inputDeviceButton.setImage(image, for: .normal)
        }
    }

    private var isToolPickerActive = false {
        didSet {
            _ = isToolPickerActive ? canvasView.becomeFirstResponder() : canvasView.resignFirstResponder()
            let image = isToolPickerActive ? UIImage(systemName: "pencil.circle.fill") : UIImage(systemName: "pencil.circle")
            toolPickerButton.setImage(image, for: .normal)
        }
    }

    private var isNavigationToolbarActive = false {
        didSet {
            let image = isNavigationToolbarActive ? UIImage(systemName: "chevron.down.circle.fill") :
            UIImage(systemName: "chevron.down.circle")
            navigationToolbarButton.setImage(image, for: .normal)
            animateNavigationToolbarView(show: isNavigationToolbarActive)
        }
    }

    // MARK: - Init

    class func instantiate() -> DrawViewController {
        let name = "\(DrawViewController.self)"
        let storyboard = UIStoryboard(name: name, bundle: nil)
        let vc = storyboard.instantiateViewController(withIdentifier: name) as! DrawViewController
        vc.setup()
        return vc
    }

    // MARK: - Setup

    private func setup() {
        let viewController = self
        let interactor = DrawInteractor()
        let presenter = DrawPresenter()
        let router = DrawRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }

    // MARK: - View Lifecycle Properties

    override var prefersHomeIndicatorAutoHidden: Bool {
        return true
    }

    // MARK: - View Lifecycle Methods

    override func viewDidLoad() {
        super.viewDidLoad()

        setupView()
    }

    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()

        updateContentSizeForDrawing()
    }

    // MARK: - Actions

    @objc private func inputDeviceButtonTapped() {
        isPencilOnly.toggle()
    }

    @objc private func undoButtonTapped() {
        canvasView.undoManager?.undo()
    }

    @objc private func redoButtonTapped() {
        canvasView.undoManager?.redo()
    }

    @objc private func toolPickerButtonTapped() {
        isToolPickerActive.toggle()
    }

    @objc private func saveButtonTapped() {
        saveImage()
    }

    @objc private func navigationToolbarButtonTapped() {
        isNavigationToolbarActive.toggle()
    }

    // MARK: - Private Methods

    private func setupView() {
        title = Const.Draw.drawTitle
        view.backgroundColor = .systemGray6

        isPencilOnly = false
        isToolPickerActive = false

        setupNavigationView()
        setupNavigationButtons()
        setupToolPicker()
        setupCanvas()
    }

    private func setupNavigationView() {
        navigationToolbarView = NavigationToolbarView.instantiate()
        navigationToolbarView?.adjustFrame(inView: navigationToolbarViewContainer)
        navigationToolbarViewContainer?.isHidden = true
        navigationToolbarViewTopConstraint.constant = -Const.NavigationToolbarView.height
    }

    private func setupNavigationButtons() {
        inputDeviceButton.setImage(UIImage(systemName: "hand.draw"), for: .normal)
        inputDeviceButton.addTarget(self, action: #selector(inputDeviceButtonTapped), for: .touchUpInside)
        undoButton.setImage(UIImage(systemName: "arrow.uturn.backward"), for: .normal)
        undoButton.addTarget(self, action: #selector(undoButtonTapped), for: .touchUpInside)
        redoButton.setImage(UIImage(systemName: "arrow.uturn.forward"), for: .normal)
        redoButton.addTarget(self, action: #selector(redoButtonTapped), for: .touchUpInside)

        toolPickerButton.setImage(UIImage(systemName: "pencil.circle"), for: .normal)
        toolPickerButton.addTarget(self, action: #selector(toolPickerButtonTapped), for: .touchUpInside)
        navigationToolbarButton.setImage(UIImage(systemName: "chevron.down.circle"), for: .normal)
        navigationToolbarButton.addTarget(self, action: #selector(navigationToolbarButtonTapped), for: .touchUpInside)

        saveButton.setImage(UIImage(systemName: "square.and.arrow.down"), for: .normal)
        saveButton.addTarget(self, action: #selector(saveButtonTapped), for: .touchUpInside)

        navigationItem.leftBarButtonItems = [
            UIBarButtonItem(customView: inputDeviceButton),
            UIBarButtonItem(customView: undoButton),
            UIBarButtonItem(customView: redoButton)
        ]

        navigationItem.rightBarButtonItems = [
            UIBarButtonItem(customView: navigationToolbarButton),
            UIBarButtonItem(customView: toolPickerButton)
        ]

        navigationToolbarView?.buttons = [
            saveButton
        ]
    }

    private func updateNavigationBar(separatorHidden: Bool) {
        guard let navigationController = navigationController as? NavigationController else { return }
        navigationController.updateSeparator(hidden: separatorHidden)
    }

    private func animateNavigationToolbarView(show isShow: Bool) {
        navigationToolbarButton.isUserInteractionEnabled = false
        navigationToolbarViewContainer?.isHidden = false
        navigationToolbarViewTopConstraint.constant = isShow ? .zero : -Const.NavigationToolbarView.height
        isShow ? updateNavigationBar(separatorHidden: true) : ()
        UIView.animate(withDuration: AnimationTime.quiteFast.rawValue, animations: {
            self.view.layoutIfNeeded()
        }, completion: { _ in
            !isShow ? self.navigationToolbarViewContainer?.isHidden = true : ()
            !isShow ? self.updateNavigationBar(separatorHidden: false) : ()
            self.navigationToolbarButton.isUserInteractionEnabled = true
        })
    }

    private func setupCanvas() {
        canvasView.delegate = self
        canvasView.drawing = drawing
        canvasView.alwaysBounceVertical = true
    }

    private func setupToolPicker() {
        toolPicker.setVisible(true, forFirstResponder: canvasView)
        toolPicker.addObserver(canvasView)
    }

    private func updateContentSizeForDrawing() {
        let canvasScale = canvasView.bounds.width / Const.Draw.maxCanvasWidth
        canvasView.maximumZoomScale = Const.Draw.maxZoomScale
        canvasView.minimumZoomScale = canvasScale
        canvasView.zoomScale = canvasScale

        let contentHeight: CGFloat
        if !canvasView.drawing.bounds.isNull {
            let extendedHeight = (canvasView.drawing.bounds.maxY) * canvasView.zoomScale
            contentHeight = max(canvasView.bounds.height, extendedHeight)
        } else {
            contentHeight = canvasView.bounds.height
        }

        canvasView.contentSize = CGSize(width: Const.Draw.maxCanvasWidth * canvasView.zoomScale, height: contentHeight)
    }

    private func saveImage() {
        guard let image = renderImage() else { return }
        let request = Draw.Request.DrawingInfo(image: image)
        interactor?.saveDrawing(request: request)
    }

    private func renderImage() -> UIImage? {
        UIGraphicsBeginImageContextWithOptions(canvasView.bounds.size, false, UIScreen.main.scale)
        canvasView.drawHierarchy(in: canvasView.bounds, afterScreenUpdates: true)
        let image = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        return image
    }

    private func presentAlert(title: String, message: String) {
        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: Const.General.doneButtonTitle, style: .default))
        present(alert, animated: true, completion: nil)
    }
}

// MARK: - DrawDisplayLogic Extension

extension DrawViewController: DrawDisplayLogic {

    func displaySavingResult(viewModel: Draw.DisplayData.SavingResult) {
        presentAlert(title: viewModel.title, message: viewModel.message)
    }
}

// MARK: - PKCanvasViewDelegate Extension

extension DrawViewController: PKCanvasViewDelegate {}

// MARK: - PKToolPickerObserver Extension

extension DrawViewController: PKToolPickerObserver {}


extension UIView {

    // MARK: - Internal Methods

    internal func adjustFrame(inView view: UIView) {
        frame = view.bounds
        view.addSubview(self)
    }

    internal func pinEdges(toView view: UIView) {
        translatesAutoresizingMaskIntoConstraints = false
        leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 0).isActive = true
        trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: 0).isActive = true
        topAnchor.constraint(equalTo: view.topAnchor, constant: 0).isActive = true
        bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: 0).isActive = true
    }
}
